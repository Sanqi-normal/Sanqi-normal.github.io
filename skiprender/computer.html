<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>动态 Mermaid 架构浏览器</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none; /* 全局禁用文本选择 */
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
            height: 100vh;
            overflow: hidden;
            display: flex;
            padding: 10px;
            gap: 10px;
        }

        /* 左侧控制面板 */
        .control-panel {
            width: 0px;
            display: none;
            flex-direction: column;
            gap: 15px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            padding: 20px;
            overflow-y: auto;
            max-height: 100%;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex: 1;
        }

        textarea {
            width: 100%;
            height: 100%;
            min-height: 300px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        /* 按钮样式 */
        button {
            padding: 8px 16px;
            background-color: #2c3e50;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            white-space: nowrap;
            flex: 1;
        }
        button:hover:not(:disabled) { background-color: #34495e; transform: translateY(-1px); }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; transform: none; }
        
        button.action-btn { background-color: #27ae60; }
        button.action-btn:hover { background-color: #2ecc71; }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="number"] {
            width: 50px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-align: center;
        }

        /* 右侧图表容器 */
        .diagram-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            overflow: hidden;
            position: relative;
        }

        /* 路径导航 */
        #breadcrumbs {
            padding: 10px 20px;
            background: #f1f3f5;
            border-bottom: 1px solid #e9ecef;
            font-size: 14px;
            color: #495057;
        }

        /* 图表容器 - 支持缩放和拖动 */
        #diagram-wrapper {
            flex: 1;
            overflow: hidden;
            position: relative;
            cursor: grab;
        }

        #diagram-container {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
            transform-origin: 0 0;
            transition: transform 0.1s ease;
        }

        /* 图表内容包装器 - 用于拖拽 */
        #diagram-content {
            position: absolute;
            top: 0;
            left: 0;
            padding: 20px;
            transform-origin: 0 0;
            transition: transform 0.1s ease;
        }

        /* 图表内部控制按钮 */
        .diagram-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 5px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .diagram-controls button {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            padding: 0;
            background-color: #2c3e50;
        }

        .diagram-controls button:hover:not(:disabled) { 
            background-color: #34495e; 
            transform: translateY(-1px); 
        }

        .diagram-controls button:disabled { 
            background-color: #bdc3c7; 
            cursor: not-allowed; 
            transform: none; 
        }

        /* 缩放指示器 */
        .zoom-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 10;
        }

        /* 强制覆盖 Mermaid 样式 */
        .node.clickable { cursor: pointer !important; }
        
        /* 简单的 Loading */
        #loading { display: none; color: #666; font-size: 14px; }
    </style>
</head>
<body>

    <!-- 左侧控制面板 -->
    <div class="control-panel" display="none">

        <div class="input-group">
            <textarea id="mermaidInput" placeholder="在此粘贴您的 Mermaid 代码 (flowchart TD ...)">
flowchart TD
    subgraph Computer[计算机完整架构 - 基础元件级细化]
        direction TB
        
        subgraph CPU[中央处理器 CPU]
            direction TB
            
            subgraph Core[处理器核心]
                direction LR
                
                subgraph CU[控制单元 CU]
                    direction TB
                    
                    subgraph InstrDec[指令译码器]
                        direction TB
                        ID_MUX1[多路复用器 // 指令字段选择]
                        ID_Decoder1[地址解码器 // 操作码解码]
                        ID_Decoder2[地址解码器 // 寄存器字段解码]
                        ID_FF1[D触发器 // 指令锁存]
                        ID_FF2[D触发器 // 状态保持]
                        
                        %% 指令译码器内部连接
                        ID_FF1 -- 锁存指令 --> ID_MUX1
                        ID_MUX1 -- 选择字段 --> ID_Decoder1
                        ID_Decoder1 -- 解码操作码 --> ID_Decoder2
                        ID_Decoder2 -- 寄存器地址 --> ID_FF2
                    end
                    
                    subgraph Microcode[微代码ROM]
                        direction TB
                        MC_ROM[ROM // 微指令存储]
                        MC_AddrDecoder[地址解码器 // 微地址解码]
                        MC_FF1[D触发器 // 微地址寄存器]
                        MC_FF2[D触发器 // 微指令寄存器]
                        MC_TriBuf1[三态缓冲器 // 微指令输出]
                        
                        %% 微代码ROM内部连接
                        MC_AddrDecoder -- 微地址 --> MC_ROM
                        MC_ROM -- 微指令字 --> MC_FF2
                        MC_FF2 -- 锁存微指令 --> MC_TriBuf1
                        MC_FF1 -- 地址保持 --> MC_AddrDecoder
                    end
                    
                    subgraph Timing[时序控制器]
                        direction TB
                        TC_Counter1[计数器 // 节拍计数]
                        TC_Counter2[计数器 // 机器周期计数]
                        TC_Decoder1[地址解码器 // 节拍解码]
                        TC_FF1[D触发器 // 状态标志]
                        TC_ClockGen[时钟生成器 // 时序生成]
                        TC_AND1[逻辑运算器 // 条件与门]
                        TC_OR1[逻辑运算器 // 条件或门]
                        
                        %% 时序控制器内部连接
                        TC_ClockGen -- 主时钟 --> TC_Counter1
                        TC_Counter1 -- 节拍计数 --> TC_Decoder1
                        TC_Decoder1 -- 节拍信号 --> TC_Counter2
                        TC_Counter2 -- 周期状态 --> TC_FF1
                        TC_FF1 -- 状态反馈 --> TC_AND1
                    end
                    
                    subgraph ControlBus[控制总线接口]
                        direction TB
                        CB_TriBuf1[三态缓冲器 // 控制信号输出]
                        CB_TriBuf2[三态缓冲器 // 状态信号输入]
                        CB_FF1[D触发器 // 控制信号锁存]
                        CB_Decoder1[地址解码器 // 设备选择]
                        
                        %% 控制总线接口内部连接
                        CB_Decoder1 -- 设备选择信号 --> CB_TriBuf1
                        CB_TriBuf1 -- 控制信号输出 --> CB_FF1
                        CB_FF1 -- 锁存控制 --> CB_TriBuf2
                    end
                    
                    %% 控制单元内部连接
                    InstrDec -- 译码操作码 --> Microcode
                    Microcode -- 微指令序列 --> Timing
                    Timing -- 时序控制信号 --> ControlBus
                    ControlBus -- 状态反馈信号 --> InstrDec
                end
                
                subgraph ALU[算术逻辑单元 ALU]
                    direction TB
                    
                    subgraph AddSub[加法器/减法器]
                        direction TB
                        AS_Adder[加法器 // 二进制加法]
                        AS_Subtractor[减法器 // 二进制减法]
                        AS_XOR1[逻辑运算器 // 补码转换]
                        AS_MUX1[多路复用器 // 运算选择]
                        AS_FF1[D触发器 // 进位锁存]
                        
                        %% 加法器/减法器内部连接
                        AS_MUX1 -- 运算选择 --> AS_Adder
                        AS_MUX1 -- 运算选择 --> AS_Subtractor
                        AS_XOR1 -- 补码控制 --> AS_Subtractor
                        AS_Adder -- 进位输出 --> AS_FF1
                        AS_Subtractor -- 借位输出 --> AS_FF1
                    end
                    
                    subgraph LogicUnit[逻辑运算单元]
                        direction TB
                        LU_AND[逻辑运算器 // 与运算]
                        LU_OR[逻辑运算器 // 或运算]
                        LU_XOR[逻辑运算器 // 异或运算]
                        LU_NOT[逻辑运算器 // 非运算]
                        LU_MUX1[多路复用器 // 逻辑操作选择]
                        
                        %% 逻辑运算单元内部连接
                        LU_MUX1 -- 操作选择 --> LU_AND
                        LU_MUX1 -- 操作选择 --> LU_OR
                        LU_MUX1 -- 操作选择 --> LU_XOR
                        LU_MUX1 -- 操作选择 --> LU_NOT
                    end
                    
                    subgraph ShiftUnit[移位器]
                        direction TB
                        SU_ShifterL[移位器 // 左移]
                        SU_ShifterR[移位器 // 右移]
                        SU_ShifterA[移位器 // 算术移位]
                        SU_MUX1[多路复用器 // 移位类型选择]
                        SU_FF1[D触发器 // 移位位数锁存]
                        
                        %% 移位器内部连接
                        SU_MUX1 -- 移位类型选择 --> SU_ShifterL
                        SU_MUX1 -- 移位类型选择 --> SU_ShifterR
                        SU_MUX1 -- 移位类型选择 --> SU_ShifterA
                        SU_FF1 -- 移位位数 --> SU_ShifterL
                        SU_FF1 -- 移位位数 --> SU_ShifterR
                        SU_FF1 -- 移位位数 --> SU_ShifterA
                    end
                    
                    subgraph ALUControl[ALU控制器]
                        direction TB
                        AC_Decoder1[地址解码器 // ALU操作码解码]
                        AC_FF1[D触发器 // 操作码锁存]
                        AC_MUX1[多路复用器 // 功能选择]
                        AC_TriBuf1[三态缓冲器 // 控制信号输出]
                        
                        %% ALU控制器内部连接
                        AC_Decoder1 -- 解码操作码 --> AC_FF1
                        AC_FF1 -- 锁存操作 --> AC_MUX1
                        AC_MUX1 -- 功能选择 --> AC_TriBuf1
                    end
                    
                    subgraph ALUFlags[ALU标志寄存器]
                        direction TB
                        AF_FF1[D触发器 // 进位标志]
                        AF_FF2[D触发器 // 零标志]
                        AF_FF3[D触发器 // 符号标志]
                        AF_FF4[D触发器 // 溢出标志]
                        AF_FF5[D触发器 // 奇偶标志]
                        AF_TriBuf1[三态缓冲器 // 标志输出]
                        
                        %% ALU标志寄存器内部连接
                        AF_FF1 -- 进位状态 --> AF_TriBuf1
                        AF_FF2 -- 零状态 --> AF_TriBuf1
                        AF_FF3 -- 符号状态 --> AF_TriBuf1
                        AF_FF4 -- 溢出状态 --> AF_TriBuf1
                        AF_FF5 -- 奇偶状态 --> AF_TriBuf1
                    end
                    
                    %% ALU内部连接
                    ALUControl -- 运算控制信号 --> AddSub
                    ALUControl -- 逻辑控制信号 --> LogicUnit
                    ALUControl -- 移位控制信号 --> ShiftUnit
                    AddSub -- 算术结果和标志 --> ALUFlags
                    LogicUnit -- 逻辑结果和标志 --> ALUFlags
                    ShiftUnit -- 移位结果和标志 --> ALUFlags
                end
                
                subgraph Registers[寄存器组]
                    direction TB
                    
                    subgraph PC[程序计数器 PC]
                        direction TB
                        PC_FF1[D触发器 // PC低8位]
                        PC_FF2[D触发器 // PC高8位]
                        PC_Adder[加法器 // PC+1]
                        PC_MUX1[多路复用器 // PC输入选择]
                        PC_TriBuf1[三态缓冲器 // PC输出]
                        
                        %% 程序计数器内部连接
                        PC_FF1 -- 低字节 --> PC_Adder
                        PC_FF2 -- 高字节 --> PC_Adder
                        PC_Adder -- 下一地址 --> PC_MUX1
                        PC_MUX1 -- 地址选择 --> PC_FF1
                        PC_MUX1 -- 地址选择 --> PC_FF2
                        PC_FF1 -- 输出低字节 --> PC_TriBuf1
                        PC_FF2 -- 输出高字节 --> PC_TriBuf1
                    end
                    
                    subgraph IR[指令寄存器 IR]
                        direction TB
                        IR_FF1[D触发器 // 操作码部分]
                        IR_FF2[D触发器 // 地址部分]
                        IR_TriBuf1[三态缓冲器 // 指令输出]
                        IR_Decoder1[地址解码器 // 指令字段分离]
                        
                        %% 指令寄存器内部连接
                        IR_FF1 -- 操作码 --> IR_Decoder1
                        IR_FF2 -- 地址字段 --> IR_Decoder1
                        IR_Decoder1 -- 分离字段 --> IR_TriBuf1
                    end
                    
                    subgraph MAR[内存地址寄存器 MAR]
                        direction TB
                        MAR_FF1[D触发器 // 地址低8位]
                        MAR_FF2[D触发器 // 地址高8位]
                        MAR_TriBuf1[三态缓冲器 // 地址输出]
                        MAR_MUX1[多路复用器 // 地址源选择]
                        
                        %% 内存地址寄存器内部连接
                        MAR_MUX1 -- 地址源选择 --> MAR_FF1
                        MAR_MUX1 -- 地址源选择 --> MAR_FF2
                        MAR_FF1 -- 输出低地址 --> MAR_TriBuf1
                        MAR_FF2 -- 输出高地址 --> MAR_TriBuf1
                    end
                    
                    subgraph MBR[内存缓冲寄存器 MBR]
                        direction TB
                        MBR_FF1[D触发器 // 数据输入锁存]
                        MBR_FF2[D触发器 // 数据输出锁存]
                        MBR_TriBuf1[三态缓冲器 // 数据输出]
                        MBR_TriBuf2[三态缓冲器 // 数据输入]
                        
                        %% 内存缓冲寄存器内部连接
                        MBR_TriBuf2 -- 输入数据 --> MBR_FF1
                        MBR_FF1 -- 锁存数据 --> MBR_FF2
                        MBR_FF2 -- 输出数据 --> MBR_TriBuf1
                    end
                    
                    subgraph ACC[累加器 ACC]
                        direction TB
                        ACC_FF1[D触发器 // 累加值存储]
                        ACC_TriBuf1[三态缓冲器 // 累加值输出]
                        ACC_MUX1[多路复用器 // 输入源选择]
                        
                        %% 累加器内部连接
                        ACC_MUX1 -- 输入源选择 --> ACC_FF1
                        ACC_FF1 -- 存储数据 --> ACC_TriBuf1
                    end
                    
                    subgraph GPR1[通用寄存器 R0-R7]
                        direction TB
                        GPR_FF[8xD触发器 // 寄存器存储]
                        GPR_MUX1[多路复用器 // 寄存器选择]
                        GPR_Decoder1[地址解码器 // 寄存器地址解码]
                        GPR_TriBuf1[三态缓冲器 // 寄存器输出]
                        
                        %% 通用寄存器内部连接
                        GPR_Decoder1 -- 寄存器选择 --> GPR_MUX1
                        GPR_MUX1 -- 选择寄存器 --> GPR_FF
                        GPR_FF -- 寄存器数据 --> GPR_TriBuf1
                    end
                    
                    subgraph StatusReg[状态寄存器 Flags]
                        direction TB
                        SR_FF1[D触发器 // 中断使能]
                        SR_FF2[D触发器 // 方向标志]
                        SR_FF3[D触发器 // 系统模式]
                        SR_TriBuf1[三态缓冲器 // 状态输出]
                        SR_MUX1[多路复用器 // 状态输入选择]
                        
                        %% 状态寄存器内部连接
                        SR_MUX1 -- 状态输入选择 --> SR_FF1
                        SR_MUX1 -- 状态输入选择 --> SR_FF2
                        SR_MUX1 -- 状态输入选择 --> SR_FF3
                        SR_FF1 -- 中断状态 --> SR_TriBuf1
                        SR_FF2 -- 方向状态 --> SR_TriBuf1
                        SR_FF3 -- 模式状态 --> SR_TriBuf1
                    end
                    
                    %% 寄存器组内部连接
                    PC -- 指令地址 --> MAR
                    IR -- 操作数地址 --> MAR
                    MBR -- 指令数据 --> IR
                    MBR -- 运算数据 --> ACC
                    MBR -- 存储数据 --> GPR1
                    ACC -- 累加值 --> ALU
                    GPR1 -- 寄存器值 --> ALU
                    ALU -- 运算结果 --> ACC
                    ALUFlags -- 状态标志 --> StatusReg
                end
                
                subgraph InternalBus[内部数据总线]
                    direction LR
                    
                    subgraph DataBus[内部数据总线]
                        direction TB
                        DB_Line[8x三态缓冲器 // 数据线驱动]
                        DB_MUX1[多路复用器 // 数据源选择]
                        DB_Decoder1[地址解码器 // 目标选择]
                        
                        %% 数据总线内部连接
                        DB_MUX1 -- 数据源选择 --> DB_Line
                        DB_Decoder1 -- 目标选择 --> DB_Line
                    end
                    
                    subgraph AddressBus[内部地址总线]
                        direction TB
                        AB_Line[16x三态缓冲器 // 地址线驱动]
                        AB_MUX1[多路复用器 // 地址源选择]
                        AB_Decoder1[地址解码器 // 地址范围解码]
                        
                        %% 地址总线内部连接
                        AB_MUX1 -- 地址源选择 --> AB_Line
                        AB_Decoder1 -- 地址解码 --> AB_Line
                    end
                    
                    subgraph ControlBusInt[内部控制总线]
                        direction TB
                        CB_Line[12x三态缓冲器 // 控制线驱动]
                        CB_Decoder1[地址解码器 // 控制信号路由]
                        CB_FF1[D触发器 // 控制信号同步]
                        
                        %% 控制总线内部连接
                        CB_Decoder1 -- 信号路由 --> CB_Line
                        CB_Line -- 控制信号 --> CB_FF1
                    end
                    
                    %% 内部总线连接
                    DataBus -- 数据传输 --> Registers
                    DataBus -- 数据传输 --> ALU
                    AddressBus -- 地址传输 --> Registers
                    ControlBusInt -- 控制信号 --> CU
                    ControlBusInt -- 控制信号 --> ALU
                    ControlBusInt -- 控制信号 --> Registers
                end
                
                %% 核心内部主要连接
                CU -- 控制信号: 指令执行控制 --> ALU
                CU -- 控制信号: 寄存器操作控制 --> Registers
                ALU -- 状态反馈: 运算状态标志 --> CU
                Registers -- 数据交换: 寄存器数据传输 --> InternalBus
                InternalBus -- 路由控制: 总线仲裁和路由 --> CU
            end
            
            subgraph CacheHierarchy[缓存层次]
                direction LR
                
                subgraph L1Cache[L1缓存]
                    direction TB
                    L1_SRAM[SRAM阵列 // 数据存储]
                    L1_TagRAM[SRAM阵列 // 标签存储]
                    L1_ValidBits[D触发器阵列 // 有效位]
                    L1_DirtyBits[D触发器阵列 // 脏位]
                    L1_Comparator[比较器 // 标签比较]
                    L1_Decoder[地址解码器 // 组选择]
                    L1_MUX[多路复用器 // 路选择]
                    L1_TriBuf[三态缓冲器 // 数据输出]
                    
                    %% L1缓存内部连接
                    L1_Decoder -- 组选择信号 --> L1_SRAM
                    L1_Decoder -- 标签索引 --> L1_TagRAM
                    L1_TagRAM -- 标签数据 --> L1_Comparator
                    L1_Comparator -- 命中判断 --> L1_MUX
                    L1_MUX -- 路选择 --> L1_TriBuf
                    L1_ValidBits -- 有效状态 --> L1_Comparator
                    L1_DirtyBits -- 脏位状态 --> L1_MUX
                end
                
                subgraph L2Cache[L2缓存]
                    direction TB
                    L2_SRAM[SRAM阵列 // 数据存储]
                    L2_TagRAM[SRAM阵列 // 标签存储]
                    L2_ValidBits[D触发器阵列 // 有效位]
                    L2_DirtyBits[D触发器阵列 // 脏位]
                    L2_Comparator[比较器 // 标签比较]
                    L2_Decoder[地址解码器 // 组选择]
                    L2_MUX[多路复用器 // 路选择]
                    L2_TriBuf[三态缓冲器 // 数据输出]
                    
                    %% L2缓存内部连接
                    L2_Decoder -- 组选择信号 --> L2_SRAM
                    L2_Decoder -- 标签索引 --> L2_TagRAM
                    L2_TagRAM -- 标签数据 --> L2_Comparator
                    L2_Comparator -- 命中判断 --> L2_MUX
                    L2_MUX -- 路选择 --> L2_TriBuf
                end
                
                subgraph L3Cache[L3缓存]
                    direction TB
                    L3_SRAM[SRAM阵列 // 数据存储]
                    L3_TagRAM[SRAM阵列 // 标签存储]
                    L3_ValidBits[D触发器阵列 // 有效位]
                    L3_DirtyBits[D触发器阵列 // 脏位]
                    L3_Comparator[比较器 // 标签比较]
                    L3_Decoder[地址解码器 // 组选择]
                    L3_MUX[多路复用器 // 路选择]
                    L3_TriBuf[三态缓冲器 // 数据输出]
                    
                    %% L3缓存内部连接
                    L3_Decoder -- 组选择信号 --> L3_SRAM
                    L3_Decoder -- 标签索引 --> L3_TagRAM
                    L3_TagRAM -- 标签数据 --> L3_Comparator
                    L3_Comparator -- 命中判断 --> L3_MUX
                    L3_MUX -- 路选择 --> L3_TriBuf
                end
                
                subgraph CacheController[缓存控制器]
                    direction TB
                    CC_StateMachine[D触发器阵列 // 状态机]
                    CC_AddressDecoder[地址解码器 // 地址解析]
                    CC_Comparator[比较器 // 一致性检查]
                    CC_MUX[多路复用器 // 缓存层级选择]
                    CC_TriBuf[三态缓冲器 // 控制信号输出]
                    
                    %% 缓存控制器内部连接
                    CC_AddressDecoder -- 地址解析 --> CC_StateMachine
                    CC_StateMachine -- 状态控制 --> CC_MUX
                    CC_Comparator -- 一致性检查 --> CC_StateMachine
                    CC_MUX -- 层级选择 --> CC_TriBuf
                end
                
                %% 缓存层次内部连接
                CacheController -- 地址映射控制: 虚拟地址映射 --> L1_Decoder
                CacheController -- 地址映射控制: 物理地址映射 --> L2_Decoder
                CacheController -- 一致性协议: 缓存一致性控制 --> L3Cache
                L1Cache -- 缓存未命中: L1缺失数据请求 --> L2Cache
                L2Cache -- 缓存未命中: L2缺失数据请求 --> L3Cache
                L3Cache -- 内存访问: L3缺失内存请求 --> CacheController
            end
            
            subgraph MMU[内存管理单元 MMU]
                direction TB
                
                subgraph TLB[转址旁路缓存 TLB]
                    direction TB
                    TLB_CAM[CAM阵列 // 虚拟地址匹配]
                    TLB_RAM[SRAM阵列 // 物理地址存储]
                    TLB_ValidBits[D触发器阵列 // 有效位]
                    TLB_Comparator[比较器 // 地址匹配]
                    TLB_Decoder[地址解码器 // TLB索引]
                    TLB_MUX[多路复用器 // 输出选择]
                    
                    %% TLB内部连接
                    TLB_CAM -- 虚拟地址匹配 --> TLB_Comparator
                    TLB_Comparator -- 匹配结果 --> TLB_MUX
                    TLB_RAM -- 物理地址 --> TLB_MUX
                    TLB_ValidBits -- 有效位检查 --> TLB_Comparator
                    TLB_Decoder -- TLB索引 --> TLB_CAM
                end
                
                subgraph PageTable[页表寄存器]
                    direction TB
                    PTR_FF1[D触发器 // 页表基址]
                    PTR_FF2[D触发器 // 页表长度]
                    PTR_TriBuf1[三态缓冲器 // 基址输出]
                    PTR_Adder[加法器 // 页表项计算]
                    
                    %% 页表寄存器内部连接
                    PTR_FF1 -- 基址寄存器 --> PTR_Adder
                    PTR_FF2 -- 长度限制 --> PTR_Adder
                    PTR_Adder -- 页表项地址 --> PTR_TriBuf1
                end
                
                subgraph SegmentationUnit[分段单元]
                    direction TB
                    SU_Adder[加法器 // 段基址+偏移量]
                    SU_Comparator[比较器 // 段界限检查]
                    SU_MUX1[多路复用器 // 段选择器]
                    SU_FF1[D触发器 // 段寄存器缓存]
                    
                    %% 分段单元内部连接
                    SU_MUX1 -- 段选择 --> SU_FF1
                    SU_FF1 -- 段基址 --> SU_Adder
                    SU_Adder -- 线性地址 --> SU_Comparator
                end
                
                subgraph PagingUnit[分页单元]
                    direction TB
                    PU_Shifter[移位器 // 页表索引提取]
                    PU_Adder[加法器 // 多级页表遍历]
                    PU_MUX1[多路复用器 // 页大小选择]
                    PU_Comparator[比较器 // 权限检查]
                    
                    %% 分页单元内部连接
                    PU_Shifter -- 索引提取 --> PU_Adder
                    PU_Adder -- 页表遍历 --> PU_Comparator
                    PU_MUX1 -- 页大小选择 --> PU_Shifter
                end
                
                %% MMU内部连接
                SegmentationUnit -- 线性地址生成: 段基址+偏移量 --> PagingUnit
                PagingUnit -- 物理地址转换: 页表遍历结果 --> TLB
                TLB -- 快速地址转换: TLB查找结果 --> MMU
                PageTable -- 页表信息: 页表基址和界限 --> PagingUnit
            end
            
            subgraph BusInterface[CPU总线接口]
                direction TB
                BI_AddressLatch[D触发器阵列 // 地址锁存]
                BI_DataLatch[D触发器阵列 // 数据锁存]
                BI_ControlLatch[D触发器阵列 // 控制信号锁存]
                BI_AddressDecoder[地址解码器 // 总线设备选择]
                BI_Arbiter[逻辑运算器阵列 // 总线仲裁]
                BI_TriBuf[三态缓冲器阵列 // 总线驱动]
                
                %% 总线接口内部连接
                BI_AddressDecoder -- 设备选择 --> BI_Arbiter
                BI_Arbiter -- 仲裁结果 --> BI_ControlLatch
                BI_ControlLatch -- 控制信号 --> BI_TriBuf
                BI_AddressLatch -- 地址信号 --> BI_TriBuf
                BI_DataLatch -- 数据信号 --> BI_TriBuf
            end
            
            %% CPU内部主要连接
            Core -- 处理请求: 指令和数据请求 --> CacheHierarchy
            CacheHierarchy -- 缓存数据: 缓存命中数据返回 --> Core
            Core -- 虚拟地址: 内存访问地址 --> MMU
            MMU -- 物理地址: 地址转换结果 --> BusInterface
            CacheHierarchy -- 内存访问: 缓存未命中请求 --> BusInterface
            BusInterface -- 总线事务: 外部总线通信 --> CPU
        end
        
        %% 继续其他部分的优化...
        
        %% === 主要系统间连接 ===
        CPU -- 内存访问: 读写请求和数据交换 --> MemoryHierarchy
        CPU -- 控制信号: 系统控制和状态反馈 --> Chipset
        Chipset -- 数据通路: I/O数据交换 --> Peripherals
        Chipset -- 总线管理: 总线仲裁和控制 --> Buses
        MemoryHierarchy -- 存储服务: 数据存储和检索 --> Chipset
        Peripherals -- 外设数据: 输入输出数据流 --> Buses
        Buses -- 通信通道: 系统组件间数据传输 --> Computer
        

    end
            </textarea>
            <div class="button-group">
                <button class="action-btn" onclick="parseAndLoad()">解析生成</button>
                <button onclick="loadDemo()">加载示例</button>
            </div>
        </div>

        <div class="controls">

            
            <div id="loading">渲染中...</div>
        </div>
    </div>

    <!-- 右侧图表区域 -->
    <div class="diagram-area">
        <div id="breadcrumbs">当前位置: Root</div>            
        <div class="control-row">
                <span style="font-size:14px; color:#555;">显示深度:</span>
                <input type="number" id="depthInput" value="2" min="1" max="999" onchange="updateDepth()">
            </div>
        <div id="diagram-wrapper">
            <div id="diagram-container">
                <div id="diagram-content"></div>
            </div>
            <div class="diagram-controls">
                <button id="backBtn" onclick="goBack()" disabled title="返回上级">⬅</button>
                <button onclick="zoomIn()" title="放大">+</button>
                <button onclick="zoomOut()" title="缩小">-</button>
                <button onclick="resetZoom()" title="重置缩放">↺</button>
            </div>
            <div class="zoom-indicator" id="zoomIndicator">100%</div>
        </div>
    </div>

    <script>
        // ==========================================
        // 1. Mermaid 解析器 (Parser)
        // ==========================================
        const demoCode = `flowchart TD
    subgraph Computer[计算机完整架构 - 基础元件级细化]
        direction TB
        
        subgraph CPU[中央处理器 CPU]
            direction TB
            
            subgraph Core[处理器核心]
                direction LR
                
                subgraph CU[控制单元 CU]
                    direction TB
                    
                    subgraph InstrDec[指令译码器]
                        direction TB
                        ID_MUX1[多路复用器 // 指令字段选择]
                        ID_Decoder1[地址解码器 // 操作码解码]
                        ID_Decoder2[地址解码器 // 寄存器字段解码]
                        ID_FF1[D触发器 // 指令锁存]
                        ID_FF2[D触发器 // 状态保持]
                        
                        %% 指令译码器内部连接
                        ID_FF1 -- 锁存指令 --> ID_MUX1
                        ID_MUX1 -- 选择字段 --> ID_Decoder1
                        ID_Decoder1 -- 解码操作码 --> ID_Decoder2
                        ID_Decoder2 -- 寄存器地址 --> ID_FF2
                    end
                    
                    subgraph Microcode[微代码ROM]
                        direction TB
                        MC_ROM[ROM // 微指令存储]
                        MC_AddrDecoder[地址解码器 // 微地址解码]
                        MC_FF1[D触发器 // 微地址寄存器]
                        MC_FF2[D触发器 // 微指令寄存器]
                        MC_TriBuf1[三态缓冲器 // 微指令输出]
                        
                        %% 微代码ROM内部连接
                        MC_AddrDecoder -- 微地址 --> MC_ROM
                        MC_ROM -- 微指令字 --> MC_FF2
                        MC_FF2 -- 锁存微指令 --> MC_TriBuf1
                        MC_FF1 -- 地址保持 --> MC_AddrDecoder
                    end
                    
                    subgraph Timing[时序控制器]
                        direction TB
                        TC_Counter1[计数器 // 节拍计数]
                        TC_Counter2[计数器 // 机器周期计数]
                        TC_Decoder1[地址解码器 // 节拍解码]
                        TC_FF1[D触发器 // 状态标志]
                        TC_ClockGen[时钟生成器 // 时序生成]
                        TC_AND1[逻辑运算器 // 条件与门]
                        TC_OR1[逻辑运算器 // 条件或门]
                        
                        %% 时序控制器内部连接
                        TC_ClockGen -- 主时钟 --> TC_Counter1
                        TC_Counter1 -- 节拍计数 --> TC_Decoder1
                        TC_Decoder1 -- 节拍信号 --> TC_Counter2
                        TC_Counter2 -- 周期状态 --> TC_FF1
                        TC_FF1 -- 状态反馈 --> TC_AND1
                    end
                    
                    subgraph ControlBus[控制总线接口]
                        direction TB
                        CB_TriBuf1[三态缓冲器 // 控制信号输出]
                        CB_TriBuf2[三态缓冲器 // 状态信号输入]
                        CB_FF1[D触发器 // 控制信号锁存]
                        CB_Decoder1[地址解码器 // 设备选择]
                        
                        %% 控制总线接口内部连接
                        CB_Decoder1 -- 设备选择信号 --> CB_TriBuf1
                        CB_TriBuf1 -- 控制信号输出 --> CB_FF1
                        CB_FF1 -- 锁存控制 --> CB_TriBuf2
                    end
                    
                    %% 控制单元内部连接
                    InstrDec -- 译码操作码 --> Microcode
                    Microcode -- 微指令序列 --> Timing
                    Timing -- 时序控制信号 --> ControlBus
                    ControlBus -- 状态反馈信号 --> InstrDec
                end
                
                subgraph ALU[算术逻辑单元 ALU]
                    direction TB
                    
                    subgraph AddSub[加法器/减法器]
                        direction TB
                        AS_Adder[加法器 // 二进制加法]
                        AS_Subtractor[减法器 // 二进制减法]
                        AS_XOR1[逻辑运算器 // 补码转换]
                        AS_MUX1[多路复用器 // 运算选择]
                        AS_FF1[D触发器 // 进位锁存]
                        
                        %% 加法器/减法器内部连接
                        AS_MUX1 -- 运算选择 --> AS_Adder
                        AS_MUX1 -- 运算选择 --> AS_Subtractor
                        AS_XOR1 -- 补码控制 --> AS_Subtractor
                        AS_Adder -- 进位输出 --> AS_FF1
                        AS_Subtractor -- 借位输出 --> AS_FF1
                    end
                    
                    subgraph LogicUnit[逻辑运算单元]
                        direction TB
                        LU_AND[逻辑运算器 // 与运算]
                        LU_OR[逻辑运算器 // 或运算]
                        LU_XOR[逻辑运算器 // 异或运算]
                        LU_NOT[逻辑运算器 // 非运算]
                        LU_MUX1[多路复用器 // 逻辑操作选择]
                        
                        %% 逻辑运算单元内部连接
                        LU_MUX1 -- 操作选择 --> LU_AND
                        LU_MUX1 -- 操作选择 --> LU_OR
                        LU_MUX1 -- 操作选择 --> LU_XOR
                        LU_MUX1 -- 操作选择 --> LU_NOT
                    end
                    
                    subgraph ShiftUnit[移位器]
                        direction TB
                        SU_ShifterL[移位器 // 左移]
                        SU_ShifterR[移位器 // 右移]
                        SU_ShifterA[移位器 // 算术移位]
                        SU_MUX1[多路复用器 // 移位类型选择]
                        SU_FF1[D触发器 // 移位位数锁存]
                        
                        %% 移位器内部连接
                        SU_MUX1 -- 移位类型选择 --> SU_ShifterL
                        SU_MUX1 -- 移位类型选择 --> SU_ShifterR
                        SU_MUX1 -- 移位类型选择 --> SU_ShifterA
                        SU_FF1 -- 移位位数 --> SU_ShifterL
                        SU_FF1 -- 移位位数 --> SU_ShifterR
                        SU_FF1 -- 移位位数 --> SU_ShifterA
                    end
                    
                    subgraph ALUControl[ALU控制器]
                        direction TB
                        AC_Decoder1[地址解码器 // ALU操作码解码]
                        AC_FF1[D触发器 // 操作码锁存]
                        AC_MUX1[多路复用器 // 功能选择]
                        AC_TriBuf1[三态缓冲器 // 控制信号输出]
                        
                        %% ALU控制器内部连接
                        AC_Decoder1 -- 解码操作码 --> AC_FF1
                        AC_FF1 -- 锁存操作 --> AC_MUX1
                        AC_MUX1 -- 功能选择 --> AC_TriBuf1
                    end
                    
                    subgraph ALUFlags[ALU标志寄存器]
                        direction TB
                        AF_FF1[D触发器 // 进位标志]
                        AF_FF2[D触发器 // 零标志]
                        AF_FF3[D触发器 // 符号标志]
                        AF_FF4[D触发器 // 溢出标志]
                        AF_FF5[D触发器 // 奇偶标志]
                        AF_TriBuf1[三态缓冲器 // 标志输出]
                        
                        %% ALU标志寄存器内部连接
                        AF_FF1 -- 进位状态 --> AF_TriBuf1
                        AF_FF2 -- 零状态 --> AF_TriBuf1
                        AF_FF3 -- 符号状态 --> AF_TriBuf1
                        AF_FF4 -- 溢出状态 --> AF_TriBuf1
                        AF_FF5 -- 奇偶状态 --> AF_TriBuf1
                    end
                    
                    %% ALU内部连接
                    ALUControl -- 运算控制信号 --> AddSub
                    ALUControl -- 逻辑控制信号 --> LogicUnit
                    ALUControl -- 移位控制信号 --> ShiftUnit
                    AddSub -- 算术结果和标志 --> ALUFlags
                    LogicUnit -- 逻辑结果和标志 --> ALUFlags
                    ShiftUnit -- 移位结果和标志 --> ALUFlags
                end
                
                subgraph Registers[寄存器组]
                    direction TB
                    
                    subgraph PC[程序计数器 PC]
                        direction TB
                        PC_FF1[D触发器 // PC低8位]
                        PC_FF2[D触发器 // PC高8位]
                        PC_Adder[加法器 // PC+1]
                        PC_MUX1[多路复用器 // PC输入选择]
                        PC_TriBuf1[三态缓冲器 // PC输出]
                        
                        %% 程序计数器内部连接
                        PC_FF1 -- 低字节 --> PC_Adder
                        PC_FF2 -- 高字节 --> PC_Adder
                        PC_Adder -- 下一地址 --> PC_MUX1
                        PC_MUX1 -- 地址选择 --> PC_FF1
                        PC_MUX1 -- 地址选择 --> PC_FF2
                        PC_FF1 -- 输出低字节 --> PC_TriBuf1
                        PC_FF2 -- 输出高字节 --> PC_TriBuf1
                    end
                    
                    subgraph IR[指令寄存器 IR]
                        direction TB
                        IR_FF1[D触发器 // 操作码部分]
                        IR_FF2[D触发器 // 地址部分]
                        IR_TriBuf1[三态缓冲器 // 指令输出]
                        IR_Decoder1[地址解码器 // 指令字段分离]
                        
                        %% 指令寄存器内部连接
                        IR_FF1 -- 操作码 --> IR_Decoder1
                        IR_FF2 -- 地址字段 --> IR_Decoder1
                        IR_Decoder1 -- 分离字段 --> IR_TriBuf1
                    end
                    
                    subgraph MAR[内存地址寄存器 MAR]
                        direction TB
                        MAR_FF1[D触发器 // 地址低8位]
                        MAR_FF2[D触发器 // 地址高8位]
                        MAR_TriBuf1[三态缓冲器 // 地址输出]
                        MAR_MUX1[多路复用器 // 地址源选择]
                        
                        %% 内存地址寄存器内部连接
                        MAR_MUX1 -- 地址源选择 --> MAR_FF1
                        MAR_MUX1 -- 地址源选择 --> MAR_FF2
                        MAR_FF1 -- 输出低地址 --> MAR_TriBuf1
                        MAR_FF2 -- 输出高地址 --> MAR_TriBuf1
                    end
                    
                    subgraph MBR[内存缓冲寄存器 MBR]
                        direction TB
                        MBR_FF1[D触发器 // 数据输入锁存]
                        MBR_FF2[D触发器 // 数据输出锁存]
                        MBR_TriBuf1[三态缓冲器 // 数据输出]
                        MBR_TriBuf2[三态缓冲器 // 数据输入]
                        
                        %% 内存缓冲寄存器内部连接
                        MBR_TriBuf2 -- 输入数据 --> MBR_FF1
                        MBR_FF1 -- 锁存数据 --> MBR_FF2
                        MBR_FF2 -- 输出数据 --> MBR_TriBuf1
                    end
                    
                    subgraph ACC[累加器 ACC]
                        direction TB
                        ACC_FF1[D触发器 // 累加值存储]
                        ACC_TriBuf1[三态缓冲器 // 累加值输出]
                        ACC_MUX1[多路复用器 // 输入源选择]
                        
                        %% 累加器内部连接
                        ACC_MUX1 -- 输入源选择 --> ACC_FF1
                        ACC_FF1 -- 存储数据 --> ACC_TriBuf1
                    end
                    
                    subgraph GPR1[通用寄存器 R0-R7]
                        direction TB
                        GPR_FF[8xD触发器 // 寄存器存储]
                        GPR_MUX1[多路复用器 // 寄存器选择]
                        GPR_Decoder1[地址解码器 // 寄存器地址解码]
                        GPR_TriBuf1[三态缓冲器 // 寄存器输出]
                        
                        %% 通用寄存器内部连接
                        GPR_Decoder1 -- 寄存器选择 --> GPR_MUX1
                        GPR_MUX1 -- 选择寄存器 --> GPR_FF
                        GPR_FF -- 寄存器数据 --> GPR_TriBuf1
                    end
                    
                    subgraph StatusReg[状态寄存器 Flags]
                        direction TB
                        SR_FF1[D触发器 // 中断使能]
                        SR_FF2[D触发器 // 方向标志]
                        SR_FF3[D触发器 // 系统模式]
                        SR_TriBuf1[三态缓冲器 // 状态输出]
                        SR_MUX1[多路复用器 // 状态输入选择]
                        
                        %% 状态寄存器内部连接
                        SR_MUX1 -- 状态输入选择 --> SR_FF1
                        SR_MUX1 -- 状态输入选择 --> SR_FF2
                        SR_MUX1 -- 状态输入选择 --> SR_FF3
                        SR_FF1 -- 中断状态 --> SR_TriBuf1
                        SR_FF2 -- 方向状态 --> SR_TriBuf1
                        SR_FF3 -- 模式状态 --> SR_TriBuf1
                    end
                    
                    %% 寄存器组内部连接
                    PC -- 指令地址 --> MAR
                    IR -- 操作数地址 --> MAR
                    MBR -- 指令数据 --> IR
                    MBR -- 运算数据 --> ACC
                    MBR -- 存储数据 --> GPR1
                    ACC -- 累加值 --> ALU
                    GPR1 -- 寄存器值 --> ALU
                    ALU -- 运算结果 --> ACC
                    ALUFlags -- 状态标志 --> StatusReg
                end
                
                subgraph InternalBus[内部数据总线]
                    direction LR
                    
                    subgraph DataBus[内部数据总线]
                        direction TB
                        DB_Line[8x三态缓冲器 // 数据线驱动]
                        DB_MUX1[多路复用器 // 数据源选择]
                        DB_Decoder1[地址解码器 // 目标选择]
                        
                        %% 数据总线内部连接
                        DB_MUX1 -- 数据源选择 --> DB_Line
                        DB_Decoder1 -- 目标选择 --> DB_Line
                    end
                    
                    subgraph AddressBus[内部地址总线]
                        direction TB
                        AB_Line[16x三态缓冲器 // 地址线驱动]
                        AB_MUX1[多路复用器 // 地址源选择]
                        AB_Decoder1[地址解码器 // 地址范围解码]
                        
                        %% 地址总线内部连接
                        AB_MUX1 -- 地址源选择 --> AB_Line
                        AB_Decoder1 -- 地址解码 --> AB_Line
                    end
                    
                    subgraph ControlBusInt[内部控制总线]
                        direction TB
                        CB_Line[12x三态缓冲器 // 控制线驱动]
                        CB_Decoder1[地址解码器 // 控制信号路由]
                        CB_FF1[D触发器 // 控制信号同步]
                        
                        %% 控制总线内部连接
                        CB_Decoder1 -- 信号路由 --> CB_Line
                        CB_Line -- 控制信号 --> CB_FF1
                    end
                    
                    %% 内部总线连接
                    DataBus -- 数据传输 --> Registers
                    DataBus -- 数据传输 --> ALU
                    AddressBus -- 地址传输 --> Registers
                    ControlBusInt -- 控制信号 --> CU
                    ControlBusInt -- 控制信号 --> ALU
                    ControlBusInt -- 控制信号 --> Registers
                end
                
                %% 核心内部主要连接
                CU -- 控制信号: 指令执行控制 --> ALU
                CU -- 控制信号: 寄存器操作控制 --> Registers
                ALU -- 状态反馈: 运算状态标志 --> CU
                Registers -- 数据交换: 寄存器数据传输 --> InternalBus
                InternalBus -- 路由控制: 总线仲裁和路由 --> CU
            end
            
            subgraph CacheHierarchy[缓存层次]
                direction LR
                
                subgraph L1Cache[L1缓存]
                    direction TB
                    L1_SRAM[SRAM阵列 // 数据存储]
                    L1_TagRAM[SRAM阵列 // 标签存储]
                    L1_ValidBits[D触发器阵列 // 有效位]
                    L1_DirtyBits[D触发器阵列 // 脏位]
                    L1_Comparator[比较器 // 标签比较]
                    L1_Decoder[地址解码器 // 组选择]
                    L1_MUX[多路复用器 // 路选择]
                    L1_TriBuf[三态缓冲器 // 数据输出]
                    
                    %% L1缓存内部连接
                    L1_Decoder -- 组选择信号 --> L1_SRAM
                    L1_Decoder -- 标签索引 --> L1_TagRAM
                    L1_TagRAM -- 标签数据 --> L1_Comparator
                    L1_Comparator -- 命中判断 --> L1_MUX
                    L1_MUX -- 路选择 --> L1_TriBuf
                    L1_ValidBits -- 有效状态 --> L1_Comparator
                    L1_DirtyBits -- 脏位状态 --> L1_MUX
                end
                
                subgraph L2Cache[L2缓存]
                    direction TB
                    L2_SRAM[SRAM阵列 // 数据存储]
                    L2_TagRAM[SRAM阵列 // 标签存储]
                    L2_ValidBits[D触发器阵列 // 有效位]
                    L2_DirtyBits[D触发器阵列 // 脏位]
                    L2_Comparator[比较器 // 标签比较]
                    L2_Decoder[地址解码器 // 组选择]
                    L2_MUX[多路复用器 // 路选择]
                    L2_TriBuf[三态缓冲器 // 数据输出]
                    
                    %% L2缓存内部连接
                    L2_Decoder -- 组选择信号 --> L2_SRAM
                    L2_Decoder -- 标签索引 --> L2_TagRAM
                    L2_TagRAM -- 标签数据 --> L2_Comparator
                    L2_Comparator -- 命中判断 --> L2_MUX
                    L2_MUX -- 路选择 --> L2_TriBuf
                end
                
                subgraph L3Cache[L3缓存]
                    direction TB
                    L3_SRAM[SRAM阵列 // 数据存储]
                    L3_TagRAM[SRAM阵列 // 标签存储]
                    L3_ValidBits[D触发器阵列 // 有效位]
                    L3_DirtyBits[D触发器阵列 // 脏位]
                    L3_Comparator[比较器 // 标签比较]
                    L3_Decoder[地址解码器 // 组选择]
                    L3_MUX[多路复用器 // 路选择]
                    L3_TriBuf[三态缓冲器 // 数据输出]
                    
                    %% L3缓存内部连接
                    L3_Decoder -- 组选择信号 --> L3_SRAM
                    L3_Decoder -- 标签索引 --> L3_TagRAM
                    L3_TagRAM -- 标签数据 --> L3_Comparator
                    L3_Comparator -- 命中判断 --> L3_MUX
                    L3_MUX -- 路选择 --> L3_TriBuf
                end
                
                subgraph CacheController[缓存控制器]
                    direction TB
                    CC_StateMachine[D触发器阵列 // 状态机]
                    CC_AddressDecoder[地址解码器 // 地址解析]
                    CC_Comparator[比较器 // 一致性检查]
                    CC_MUX[多路复用器 // 缓存层级选择]
                    CC_TriBuf[三态缓冲器 // 控制信号输出]
                    
                    %% 缓存控制器内部连接
                    CC_AddressDecoder -- 地址解析 --> CC_StateMachine
                    CC_StateMachine -- 状态控制 --> CC_MUX
                    CC_Comparator -- 一致性检查 --> CC_StateMachine
                    CC_MUX -- 层级选择 --> CC_TriBuf
                end
                
                %% 缓存层次内部连接
                CacheController -- 地址映射控制: 虚拟地址映射 --> L1_Decoder
                CacheController -- 地址映射控制: 物理地址映射 --> L2_Decoder
                CacheController -- 一致性协议: 缓存一致性控制 --> L3Cache
                L1Cache -- 缓存未命中: L1缺失数据请求 --> L2Cache
                L2Cache -- 缓存未命中: L2缺失数据请求 --> L3Cache
                L3Cache -- 内存访问: L3缺失内存请求 --> CacheController
            end
            
            subgraph MMU[内存管理单元 MMU]
                direction TB
                
                subgraph TLB[转址旁路缓存 TLB]
                    direction TB
                    TLB_CAM[CAM阵列 // 虚拟地址匹配]
                    TLB_RAM[SRAM阵列 // 物理地址存储]
                    TLB_ValidBits[D触发器阵列 // 有效位]
                    TLB_Comparator[比较器 // 地址匹配]
                    TLB_Decoder[地址解码器 // TLB索引]
                    TLB_MUX[多路复用器 // 输出选择]
                    
                    %% TLB内部连接
                    TLB_CAM -- 虚拟地址匹配 --> TLB_Comparator
                    TLB_Comparator -- 匹配结果 --> TLB_MUX
                    TLB_RAM -- 物理地址 --> TLB_MUX
                    TLB_ValidBits -- 有效位检查 --> TLB_Comparator
                    TLB_Decoder -- TLB索引 --> TLB_CAM
                end
                
                subgraph PageTable[页表寄存器]
                    direction TB
                    PTR_FF1[D触发器 // 页表基址]
                    PTR_FF2[D触发器 // 页表长度]
                    PTR_TriBuf1[三态缓冲器 // 基址输出]
                    PTR_Adder[加法器 // 页表项计算]
                    
                    %% 页表寄存器内部连接
                    PTR_FF1 -- 基址寄存器 --> PTR_Adder
                    PTR_FF2 -- 长度限制 --> PTR_Adder
                    PTR_Adder -- 页表项地址 --> PTR_TriBuf1
                end
                
                subgraph SegmentationUnit[分段单元]
                    direction TB
                    SU_Adder[加法器 // 段基址+偏移量]
                    SU_Comparator[比较器 // 段界限检查]
                    SU_MUX1[多路复用器 // 段选择器]
                    SU_FF1[D触发器 // 段寄存器缓存]
                    
                    %% 分段单元内部连接
                    SU_MUX1 -- 段选择 --> SU_FF1
                    SU_FF1 -- 段基址 --> SU_Adder
                    SU_Adder -- 线性地址 --> SU_Comparator
                end
                
                subgraph PagingUnit[分页单元]
                    direction TB
                    PU_Shifter[移位器 // 页表索引提取]
                    PU_Adder[加法器 // 多级页表遍历]
                    PU_MUX1[多路复用器 // 页大小选择]
                    PU_Comparator[比较器 // 权限检查]
                    
                    %% 分页单元内部连接
                    PU_Shifter -- 索引提取 --> PU_Adder
                    PU_Adder -- 页表遍历 --> PU_Comparator
                    PU_MUX1 -- 页大小选择 --> PU_Shifter
                end
                
                %% MMU内部连接
                SegmentationUnit -- 线性地址生成: 段基址+偏移量 --> PagingUnit
                PagingUnit -- 物理地址转换: 页表遍历结果 --> TLB
                TLB -- 快速地址转换: TLB查找结果 --> MMU
                PageTable -- 页表信息: 页表基址和界限 --> PagingUnit
            end
            
            subgraph BusInterface[CPU总线接口]
                direction TB
                BI_AddressLatch[D触发器阵列 // 地址锁存]
                BI_DataLatch[D触发器阵列 // 数据锁存]
                BI_ControlLatch[D触发器阵列 // 控制信号锁存]
                BI_AddressDecoder[地址解码器 // 总线设备选择]
                BI_Arbiter[逻辑运算器阵列 // 总线仲裁]
                BI_TriBuf[三态缓冲器阵列 // 总线驱动]
                
                %% 总线接口内部连接
                BI_AddressDecoder -- 设备选择 --> BI_Arbiter
                BI_Arbiter -- 仲裁结果 --> BI_ControlLatch
                BI_ControlLatch -- 控制信号 --> BI_TriBuf
                BI_AddressLatch -- 地址信号 --> BI_TriBuf
                BI_DataLatch -- 数据信号 --> BI_TriBuf
            end
            
            %% CPU内部主要连接
            Core -- 处理请求: 指令和数据请求 --> CacheHierarchy
            CacheHierarchy -- 缓存数据: 缓存命中数据返回 --> Core
            Core -- 虚拟地址: 内存访问地址 --> MMU
            MMU -- 物理地址: 地址转换结果 --> BusInterface
            CacheHierarchy -- 内存访问: 缓存未命中请求 --> BusInterface
            BusInterface -- 总线事务: 外部总线通信 --> CPU
        end
        
        %% 继续其他部分的优化...
        
        %% === 主要系统间连接 ===
        CPU -- 内存访问: 读写请求和数据交换 --> MemoryHierarchy
        CPU -- 控制信号: 系统控制和状态反馈 --> Chipset
        Chipset -- 数据通路: I/O数据交换 --> Peripherals
        Chipset -- 总线管理: 总线仲裁和控制 --> Buses
        MemoryHierarchy -- 存储服务: 数据存储和检索 --> Chipset
        Peripherals -- 外设数据: 输入输出数据流 --> Buses
        Buses -- 通信通道: 系统组件间数据传输 --> Computer
    end`;
        /**
         * 将 Mermaid 文本解析为树状结构
         * 这是一个简化版的解析器，专门针对 subgraph 嵌套结构优化
         */
        function parseMermaidCode(code) {
            // 清理代码：去除 标记，去除多余空格
            const cleanCode = code.trim();
            const lines = cleanCode.split('\n');
            
            const root = { id: 'Root', label: 'Root', children: [], links: [] };
            const nodeStack = [root]; // 用于追踪 subgraph 嵌套
            const allLinks = [];      // 存储所有解析到的连线
            const nodeMap = {};       // ID -> Node 对象的映射
            
            // 简单的正则匹配
            const subgraphRegex = /^\s*subgraph\s+(\w+)(?:\[(.*?)\])?/;
            const endRegex = /^\s*end\s*$/;
            const directionRegex = /^\s*direction\s+(TB|LR|BT|RL)/;
            // 匹配节点: ID[Label] 或 ID
            const nodeRegex = /^\s*(\w+)(?:\[(.*?)\])?(?:\s*:::.*)?$/; 
            // 匹配连线: A --> B, A -- text --> B
            // 注意：这里简单处理，假设一行主要是一个连线
            const linkRegex = /^\s*(\w+)\s*-.->\s*(\w+)/; 
            const linkWithTextRegex = /^\s*(\w+)\s*--.*?-->\s*(\w+)/;

            lines.forEach(line => {
                line = line.trim();
                if (!line || line.startsWith('%%') || line.startsWith('flowchart') || line.startsWith('graph')) return;

                const currentParent = nodeStack[nodeStack.length - 1];

                // 1. 检测连线 (优先检测，防止误判为节点)
                let linkMatch = line.match(linkWithTextRegex) || line.match(linkRegex);
                if (linkMatch) {
                    const from = linkMatch[1];
                    const to = linkMatch[2];
                    // 保存连线，去除样式定义等杂质
                    const fullLink = line.split(':::')[0]; 
                    allLinks.push({ from, to, raw: fullLink });
                    return;
                }

                // 2. 检测 Subgraph 开始
                const subMatch = line.match(subgraphRegex);
                if (subMatch) {
                    const id = subMatch[1];
                    const label = subMatch[2] || id;
                    const newNode = { 
                        id, 
                        label: label.replace(/["']/g, ""), // 去除引号
                        children: [], 
                        type: 'subgraph' 
                    };
                    
                    currentParent.children.push(newNode);
                    nodeStack.push(newNode);
                    nodeMap[id] = newNode;
                    return;
                }

                // 3. 检测 End
                if (endRegex.test(line)) {
                    if (nodeStack.length > 1) {
                        nodeStack.pop();
                    }
                    return;
                }

                // 4. 检测 Direction
                const dirMatch = line.match(directionRegex);
                if (dirMatch) {
                    currentParent.direction = dirMatch[1];
                    return;
                }

                // 5. 检测普通节点 (叶子节点)
                // 排除连线定义行，排除 subgraph 关键字
                if (!line.includes('-->') && !line.includes('-.->') && !line.startsWith('subgraph')) {
                    // 尝试提取 ID 和 Label
                    // 简单的分割逻辑：先看有没有方括号
                    let id, label;
                    if (line.includes('[')) {
                        const parts = line.split('[');
                        id = parts[0].trim();
                        label = parts[1].replace(']', '').trim();
                    } else {
                        id = line.split(':::')[0].trim(); // 去除样式类
                        label = id;
                    }

                    if (id && /^\w+$/.test(id)) { // 确保ID有效
                        const newNode = { id, label, children: [], type: 'leaf' };
                        currentParent.children.push(newNode);
                        nodeMap[id] = newNode;
                    }
                }
            });

            // 将全局连线挂载到 Root (渲染时会过滤)
            root.links = allLinks;
            
            // 如果 Root 只有一个子节点且是 Computer，直接把 Computer 当作起始点更好看
            if (root.children.length === 1) {
                const actualRoot = root.children[0];
                actualRoot.links = allLinks; // 传递连线
                return actualRoot;
            }

            return root;
        }

        // ==========================================
        // 2. 状态管理与渲染逻辑
        // ==========================================
        
        let fullTree = null;
        let historyStack = [];
        let currentNode = null;
        let viewDepth = 2;
        let scale = 1;
        let isDragging = false;
        let startX, startY, offsetX = 0, offsetY = 0;

        mermaid.initialize({ 
            startOnLoad: false,
            securityLevel: 'loose',
            theme: 'base',
            themeVariables: {
                primaryColor: '#e1f5fe',
                edgeLabelBackground: '#ffffff',
                clusterBkg: '#ffffff',
                clusterBorder: '#2c3e50'
            }
        });

        // 绑定到 window 以便 HTML 调用
        window.parseAndLoad = function() {
            const code = document.getElementById('mermaidInput').value;
            console.log(code);
            if (!code.trim()) {
                alert("请输入 Mermaid 代码");
                return;
            }
            
            try {
                fullTree = parseMermaidCode(code);
                console.log("Parsed Tree:", fullTree); // 调试用
                
                // 重置状态
                historyStack = [];
                currentNode = fullTree;
                resetZoom();
                renderGraph();
            } catch (e) {
                console.error(e);
                alert("解析出错，请检查代码格式");
            }
        };

        window.updateDepth = function() {
            viewDepth = parseInt(document.getElementById('depthInput').value) || 2;
            resetZoom();
            renderGraph();
        };

        window.goBack = function() {
            if (historyStack.length > 0) {
                currentNode = historyStack.pop();
                renderGraph();
            }
        };

        window.handleNodeClick = function(nodeId) {
            // 在全树中查找节点
            const target = findNodeInTree(fullTree, nodeId);
            
            if (target && target.children && target.children.length > 0) {
                historyStack.push(currentNode);
                currentNode = target;
                resetZoom();
                renderGraph();
            }
        };

        function findNodeInTree(node, id) {
            if (node.id === id) return node;
            if (node.children) {
                for (let child of node.children) {
                    const found = findNodeInTree(child, id);
                    if (found) return found;
                }
            }
            return null;
        }

        // ==========================================
        // 3. 递归生成器 (核心逻辑)
        // ==========================================

        /**
         * 递归生成 Mermaid 语法
         * @param node 当前遍历到的节点
         * @param currentDepth 当前递归深度 (相对渲染起点)
         * @param maxDepth 最大允许显示的深度
         * @param visibleNodeIds 用于收集所有渲染出来的节点ID (用于连线过滤)
         */
        function buildMermaidString(node, currentDepth, maxDepth, visibleNodeIds) {
            let syntax = "";
            const isLeaf = !node.children || node.children.length === 0;
            const isMaxDepth = currentDepth >= maxDepth;

            // 收集可见ID
            visibleNodeIds.add(node.id);

            // 1. 如果是叶子节点，或已达到显示深度上限，直接渲染为普通节点
            if (isLeaf || isMaxDepth) {
                // 判断是否还有隐藏的子节点 (用于决定是否显示为蓝色可点击)
                const hasHiddenChildren = !isLeaf;
                const styleClass = hasHiddenChildren ? "nav" : "leaf";
                
                // 生成节点语法: ID["Label"]:::class
                syntax += `${node.id}["${node.label}"]:::${styleClass}\n`;
                
                if (hasHiddenChildren) {
                    syntax += `click ${node.id} call handleNodeClick("${node.id}")\n`;
                }
                return syntax;
            }

            // 2. 如果是容器节点 (Subgraph) 且未达深度上限
            // 注意：根节点通常不需要套 subgraph，除非它是嵌套在内部的
            const isRootOfView = (currentDepth === 0);
            
            if (!isRootOfView) {
                syntax += `subgraph ${node.id} ["${node.label}"]\n`;
                if (node.direction) syntax += `direction ${node.direction}\n`;
            }

            // 递归处理子节点
            node.children.forEach(child => {
                syntax += buildMermaidString(child, currentDepth + 1, maxDepth, visibleNodeIds);
            });

            if (!isRootOfView) {
                syntax += `end\n`;
            }

            return syntax;
        }

        async function renderGraph() {
            const content = document.getElementById('diagram-content');
            const backBtn = document.getElementById('backBtn');
            const breadcrumbs = document.getElementById('breadcrumbs');
            const loading = document.getElementById('loading');

            loading.style.display = 'block';
            
            // 0. 准备数据
            const visibleNodeIds = new Set();
            
            // 1. 生成节点结构
            let graphDefinition = `graph ${currentNode.direction || 'TB'}\n`;
            graphDefinition += `classDef nav fill:#e3f2fd,stroke:#2196f3,stroke-width:2px,cursor:pointer;\n`;
            graphDefinition += `classDef leaf fill:#ffffff,stroke:#333,stroke-width:1px;\n`;

            // 从 currentNode 开始递归构建，初始深度为 0
            // viewDepth 是用户设定的显示层数
            graphDefinition += buildMermaidString(currentNode, 0, viewDepth, visibleNodeIds);

            // 2. 智能连线生成
            // 遍历 fullTree 中的所有连线，如果 source 和 target 都在 visibleNodeIds 中，则添加
            // 这是一个全局搜索，对于大型图表可能需要优化，但在前端万级以下节点没问题
            // 优化：我们假设 parseMermaidCode 将所有连线存在了 Root (fullTree) 或者 currentNode 上
            // 实际上连线是跨层级的。最简单的方法是使用全树的连线列表。
            
            const linksSource = fullTree.links || []; 
            linksSource.forEach(link => {
                if (visibleNodeIds.has(link.from) && visibleNodeIds.has(link.to)) {
                    graphDefinition += `${link.raw}\n`;
                }
            });

            // 3. 渲染
            const uniqueId = 'graph-' + Date.now();
            try {
                const { svg, bindFunctions } = await mermaid.render(uniqueId, graphDefinition);
                content.innerHTML = svg;
                if (bindFunctions) bindFunctions(content);
            } catch (error) {
                console.error("Render Error", error);
                // 容错处理：如果 Mermaid 渲染失败（通常是因为空图或语法冲突），显示提示
                content.innerHTML = `<div style="color:red; padding:20px;">渲染错误: ${error.message} <br> 可能是当前视图没有子节点或深度过深。</div>`;
            }

            // 4. 更新 UI
            loading.style.display = 'none';
            backBtn.disabled = historyStack.length === 0;
            
            // 生成面包屑路径
            let pathTxt = "Root";
            if (historyStack.length > 0) {
                // 简单展示当前节点名，也可以遍历 stack 生成完整路径
                pathTxt = `... > ${currentNode.label}`;
            } else if (currentNode.label) {
                pathTxt = currentNode.label;
            }
            breadcrumbs.innerText = `当前位置: ${pathTxt} (当前显示层数: ${viewDepth})`;
        }
        
        // ==========================================
        // 4. 缩放和拖动功能 (已修改)
        // ==========================================
        
        function zoomIn() {
            // 获取鼠标位置
            const wrapper = document.getElementById('diagram-wrapper');
            const rect = wrapper.getBoundingClientRect();
            const mouseX = lastMouseX - rect.left;
            const mouseY = lastMouseY - rect.top;
            
            // 计算缩放前的鼠标位置相对于内容的比例
            const contentX = (mouseX - offsetX) / scale;
            const contentY = (mouseY - offsetY) / scale;
            
            // 更新缩放比例
            scale += 0.1*scale;
            
            // 计算缩放后的偏移量，使鼠标下的点保持在同一位置
            offsetX = mouseX - contentX * scale;
            offsetY = mouseY - contentY * scale;
            
            updateZoom();
        }
        
        function zoomOut() {
            // 获取鼠标位置
            const wrapper = document.getElementById('diagram-wrapper');
            const rect = wrapper.getBoundingClientRect();
            const mouseX = lastMouseX - rect.left;
            const mouseY = lastMouseY - rect.top;
            
            // 计算缩放前的鼠标位置相对于内容的比例
            const contentX = (mouseX - offsetX) / scale;
            const contentY = (mouseY - offsetY) / scale;
            
            // 更新缩放比例
            scale = Math.max(0.1, 0.9*scale);
            
            // 计算缩放后的偏移量，使鼠标下的点保持在同一位置
            offsetX = mouseX - contentX * scale;
            offsetY = mouseY - contentY * scale;
            
            updateZoom();
        }
        
        function resetZoom() {
            const wrapper = document.getElementById('diagram-wrapper');
            const content = document.getElementById('diagram-content');
            
            // 重置缩放比例
            scale = 1;
            
            // 计算居中偏移
            const wrapperRect = wrapper.getBoundingClientRect();
            const contentRect = content.getBoundingClientRect();
            
            // 将内容居中显示
            offsetX = (wrapperRect.width - contentRect.width * scale) / 2;
            offsetY = (wrapperRect.height - contentRect.height * scale) / 2;
            
            updateZoom();
        }
        
        function updateZoom() {
            const content = document.getElementById('diagram-content');
            const indicator = document.getElementById('zoomIndicator');
            
            content.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
            indicator.textContent = `${Math.round(scale * 100)}%`;
        }
        
        // 记录鼠标位置
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        // 初始化拖拽功能
        function initDrag() {
            const wrapper = document.getElementById('diagram-wrapper');
            const content = document.getElementById('diagram-content');
            
            // 记录鼠标位置
            wrapper.addEventListener('mousemove', (e) => {
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });
            
            wrapper.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return; // 只处理左键
                
                isDragging = true;
                startX = e.clientX - offsetX;
                startY = e.clientY - offsetY;
                wrapper.style.cursor = 'grabbing';
            });
            
            wrapper.addEventListener('mouseleave', () => {
                isDragging = false;
                wrapper.style.cursor = 'grab';
            });
            
            wrapper.addEventListener('mouseup', () => {
                isDragging = false;
                wrapper.style.cursor = 'grab';
            });
            
            wrapper.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                e.preventDefault();
                
                offsetX = e.clientX - startX;
                offsetY = e.clientY - startY;
                
                updateZoom();
            });
            
            // 滚轮缩放功能
            wrapper.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                // 计算缩放前的鼠标位置
                const rect = wrapper.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // 计算鼠标位置相对于内容的比例
                const contentX = (mouseX - offsetX) / scale;
                const contentY = (mouseY - offsetY) / scale;
                
                // 更新缩放比例
                if (e.deltaY < 0) {
                    // 向上滚动，放大
                    scale += 0.1*scale;
                } else {
                    // 向下滚动，缩小
                    scale = Math.max(0.1, 0.9*scale);
                }
                
                // 计算缩放后的偏移量，使鼠标下的点保持在同一位置
                offsetX = mouseX - contentX * scale;
                offsetY = mouseY - contentY * scale;
                
                // 应用缩放
                updateZoom();
            }, { passive: false });
        }
        
        // 预置 Demo 加载逻辑
        window.loadDemo = function() {
            document.getElementById('mermaidInput').value = demoCode;
            parseAndLoad();
        }

        // 初始化
        document.addEventListener('DOMContentLoaded', () => {
            // 自动加载一次 Demo 以便展示效果
            updateDepth();
            loadDemo();
            resetZoom();
            initDrag();
        });

    </script>
</body>
</html>